
# Clean Code


- assertNotSame : 두 객체 참조가 서로 다른 메모리 주소 가리키는지 - 서로 다른 인스턴스 검증
- assertNotEquals : 두 객체 값 or 상태가 같지 않은지 검사 - equals 사용 , 객체 내부 동등성 검증

## AvoidMistake

```java
List<Car> carList = List.of(new Car("poby"), new Car("joyson"));  
  
Cars cars = new Cars(carList);  
  
Assertions.assertNotEquals(carList, cars.getCars());  
Assertions.assertNotSame(carList, cars.getCars());
```
- assertNotEquals 는 Fail
- assertNotSame 은 Pass

#### 불변 객체

```java
class Position {  
    private int value;  
  
    Position() {  
        this(0);  
    }  
  
    Position(final int value) {  
        this.value = value;  
    }  
  
    public Position increase() {  
        return new Position(value + 1);  
    }  
  
    public int getValue() {  
        return value;  
    }  
  
    @Override  
    public boolean equals(final Object o) {  
        if (this == o) return true;  
        if (o == null || getClass() != o.getClass()) return false;  
        final Position position = (Position) o;  
        return value == position.value;  
    }  
  
    @Override  
    public int hashCode() {  
        return Objects.hash(value);  
    }  
}
```

객체 상태 변경 불가능
-> 변경 있을 때마다 새로운 객체 생성
=> 결국 성능상 이슈 발생

```java
record Position(int value) {  
    private static final int CACHE_MAX_SIZE = 127;  
    private static final Map<Integer, Position> CACHE = new ConcurrentHashMap<>();  
  
    public static Position startingPoint() {  
        return valueOf(0);  
    }  
  
    public static Position valueOf(final int value) {  
        if (value < CACHE_MAX_SIZE) {  
            return CACHE.computeIfAbsent(value, Position::new);  
        }  
        return new Position(value);  
    }  
  
    public Position increase() {  
        return valueOf(value + 1);  
    }  
}
```

정적 팩토리 메소드를 통해 값을 받자
-> 값을 캐싱 & 캐싱된 값 받아오기 가능

```java
public CarForEnhancedCache forward() {  
    return CarForEnhancedCache.of(name, position.increase());  
}
```

forward 마다 Car 를 반환
-> 변경 때마다 Car 도 새로 생성 ( 내부 Position 도 생성 )
=> Cache 가 있다고 해도 , 이는 매우 비효율적

```java
public void forward() {  
    position = position.increase();  
}
```

forward 시 position 을 내부에서 교체하자! ( 적절한 시점에 불변 -> 가변 해제 )
-> 성능적 이점 + 불변 객체의 장점 & 가변 객체 장점 동시에 사용 가능
-> 동일 컨텍스트에서만 불변 객체 + 다른 컨텍스트 사용될 수 있는 지점에선 가변 객체처럼 사용되게
=> 결국 상황 과 설계에 따라 달라지고 , 어떤 방법이 더 좋은지는 구현하며 판단해야함

```java
RacingGame(final List<Car> participants) {  
    this.participants = new ArrayList<>(participants);  
}

List<Car> getParticipants() {  
    return new ArrayList<>(participants);  
}
```

객체 자체를 주입하는게 아닌 복사를 통해 초기화 / 반환 하자
=> 방어적 복사
### 방어적 복사

외부에서 값을 변경시킬 수 없다
-> 원본과 주소 공유를 끊어내기 때문

participants 주소 != this.participants 주소

하지만 결국 리스트 변경만 막음 ( add , remove )

리스트 내부 객체 변경시 , 둘다 모두 영향 받음!

=> 방지하고 싶으면 깊은 복사를 구현하자

#### 깊은 복사

```java
public Cars(List<Car> cars) {  
    this.cars = cars.stream()  
                    .map(Car::copy)  
                    .toList();  
}  
  
  
public List<Car> getCars() {  
    return cars;  
}
==================================================================

public Car(String name) {  
    this.name = name;  
}  
public static Car copy(Car car) {  
    return new Car(car.getName());  
}
```

결국 cost 가 비쌈

getter -> 방어적 복사 -> 깊은 복사 순으로 고려해서 사용을 하자

----

## Predictable

```java
List<Car> participants;

participants
	.stream()
	.mapToInt(Car::position)
	.averge();
```

해당 값은 Optional 반환
( List<`Car`> 에 요소가 하나도 없을수 있으므로 )

이때 참여자가 없다는 것은 어떻게 처리해야 할까?

- orElse(-1) : 특정 값 반환 의도 ( 실수를 유발하는 코드 )
- isEmpty() -> return null : empty 인지 확인 후 null 반환 ( NPE 에 주의해야 함 )
- isEmpty() -> Optional.empty() : empty 인지 확인 후 Optional<> 로 재반한
- orElseThrow() : 예외 발생 의도 ( 코드 중복하지 않고 처리가능 )

=> 결국 , 상황에 맞게 선택해나가야 함

```java
int move(final int power) {  
    if (power <= 4) {  
        return position;  
    }  
    return ++position;  
}
```

이동과 조회를 동시에 할 시 부수효과 발생 가능 ( 의도한 값이 조회가 안될 가능성 존재 )
-> 이동 과 조회 분리
=> CQS ( Command And Query Separation ) 원칙 준수
#### CQS

##### Command
- 객체 상태 변경 작업 수행 , 값 반환 X
즉 position 변경을 하게 하나 , position 값을 반환하지 않아야 함

##### Query
- 객체 상태 대한 값 반환 , 상태 변경 X
즉 position 을 반환하나 , 값을 변경하지 않아야 함

=> 메소드 역활 명확 + 복잡성 관리 쉬워짐 ( 병렬 , 동시성 처리 시 매우 유용 )

```java
void move(final int power) {  
    if (power <= 4) {  
        return;  
    }  
    if (position >= 5) {  
        // Note: 중요한 동작을 무시하는 것은 버그를 유발할 수 있다.  
        throw new IllegalStateException("더 이상 움직일 수 없습니다.");  
    }  
  
    position++;  
}
```

power가 4보다 같거나 작을 시 return - 코드를 통해 기능 요구사항의 의도를 드러냄
postion 5보다 같거나 클 시 exception - 동작 중 발생한 문제점은 예외로 의도를 드러냄

```java
private static final String PLUS = "PLUS";  
private static final String MINUS = "MINUS";

public static int calculate(  
        final String command,  
        final int left,  
        final int right  
)
=>
enum Command {  
    PLUS,  
    MINUS,  
}
public static int calculate(  
        final Command command,  
        final int left,  
        final int right  
)
```

문자열 equals 처리가 아닌 Enum 으로 처리하자

```java
for (final Command command : Command.values()) {  
    // Note: 런타임 시점에 해당 명령을 처리하는 코드를 놓치지 않을 수 있다.  
    assertThatCode(() -> {  
        Calculator.calculate(command, 1, 2);  
    }).doesNotThrowAnyException();  
}
```

Enum 과 연산을 매핑할 때 놓치는 명령어가 있는지 검사하는 코드

```java
 {  
    return switch (command) {  
        case PLUS -> left + right;  
        case MINUS -> left - right;  
//        case MULTIPLY -> left * right;
    };  
}
```

calculate 함수가 모든 Enum 을 처리하지 않으면 컴파일 에러가 발생

```java
enum Command {  
    PLUS((left, right) -> left + right),  
    MINUS((left, right) -> left - right),  
    MULTIPLY((left, right) -> left * right);  
  
    private final BiFunction<Integer, Integer, Integer> function;  
  
    Command(final BiFunction<Integer, Integer, Integer> function) {  
        this.function = function;  
    }
```

열거형 역시 Class -> 객체로 사용 가능
열거형에서 역활을 수행하게 부여

응집도가 높아질 수도 있으나 , 적절치 않을 수 있음
=> 판단하에 잘 사용하자

---

## ReadableCode

```java
class Car {

	private int position = 0;

	void forward() {
		if (position > 5) {
			throw new IllegalStateException();
		}
		position += 1;
	}
}
```

물론 이 코드도 자동차의 이동을 담당하는 코드

```java
class Position {
	private static final Integer INITIAL_POSITION = 0;  
	private static final Integer MAX_POSITION = 5;  
	private final int value;
	
	public Position() {  
	    this(INITIAL_POSITION);  
	}  
	  
	public Position(final int value) {  
	    if (value > MAX_POSITION) {  
	        throw new IllegalStateException("최대 5까지만 움직일 수 있습니다.");  
	    }  
	  
	    this.value = value;  
	}  
	  
	Position forward() {  
	    return new Position(value + 1);  
	}
}
```

자동차의 위치를 담당하는 Position 생성

뭐가 좋은가?
-> 역활 & 담당 분리

- 자동차가 자신의 위치를 이동하는 로직에 대해 알 필요가 있을까?
	-> Position 이 자신의 위치를 이동
- 자동차가 5까지 밖에 이동을 못한다는 걸 알 필요가 있을까?
	-> 자동차의 위치를 담당하는 Position 이 관리

로또는 ?

로또 숫자 하나를 담당하는 LottoNumber
로또 숫자들을 가지는 Lotto

쪼갤수록 코드는 더 견고해지고 , 각자의 역활을 더 아름답게 맡는다

```java
final var crew = new Crew(  
        /*name*/ "Neo",  
        /*likeMenuItems*/ Set.of("쌈밥", "김치찌개", "탕수육", "비빔밥"),  
        /*dislikeMenuItems*/ Set.of("샐러드", "파인애플 볶음밥", "미소시루", "하이라이스")  
);
```

Java 는 Named Parameter 지원 X
같은 자료형을 추구하는 경우 -> 실수 유발 & 혼란 유발

=> Builder 패턴을 사용하자

Builder 와 공통 의미를 나타내는 도메인을 묶어서 간결하게 사용을 하자
likeMenuItems , dislikeMenuItems => Taste
Taste 빌드 후 , Crew 빌드

항상 최선인가?
-> 의미는 명확해지나 , 객체가 많아져 유지보수성 떨어질 수 있다
=> 적절한 추상화 수준을 유지하자

```java
private final Set<String> menuItems;  
  
public Menu(final Set<String> menuItems) {  
    this.menuItems = menuItems;  
}
```

메뉴가 무조건 중복이 안되야 한다는걸 알려주는데
이거보다 더 효과적인게 있는가
