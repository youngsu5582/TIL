![300](https://i.imgur.com/TfZBzWa.png)

Enum 값의 stream 을
Collection API 의 stream 처럼 사용할꺼면 내장 static stream 을 만드는 것도 좋은 방법!


![](https://i.imgur.com/uMr3sCD.png)

카드는 무조건 52개 -> 미리 캐싱을 하자
두개의 객체를 연결해서 Key 를 만들어야 한다면?
String 을 통해 만드는 것 역시 Not Bad

Pool 과 Caching 의 차이는??
#### Cache

자주 사용되는 값을 저장하는 공간
-> DB 에서 조회 테이블이 자주 사용되거나 파일에서 읽힐 떄 이를 메모리에 유지 & 새로고침

캐시 내 객체 수명 관리하지만 , 항목 생성하는게 아닌 단순 객체를 저장
- 데이터 반복 액세스 감소
- 데이터 무결성
- 자주 사용되는 데이터 저장
##### Pool

풀이 자체로 관리하는 여러 자원의 그룹
-> DB 커넥션 ( 연결이 필요할 시 풀에서 가져옴 , 사용이 끝날 시 풀에 반환 )

풀은 오버헤드 감소 , 리소스 접근 제어에 사용
- 리소스 재사용
- 리소스 생명 주기 관리
- 오버헤드 감소
---

타입을 선언하는게 , 타입도 알려주고 명확하나 라고 할 수 있으나
네오는 var 로 선언 역시 선호!
-> 중요한건 타입이 아닌 행위다

- 가독성 향상 ( 코드 간결 , 중복 타입 선언 제거해 가독성 향상 )
- 유지 보수성 증가 ( 코드 변경 시 , 변수 타입 모두 변경할 필요 X -> 유지보수성 증가 )
- 컴파일 시점 검증
- 코드 간소화

객체 와 코드에 대한 믿음을 가지고 사용하자
( 코드를 들어가지 않고 , 입력 값 과 출력 값에 기반해서 )

```java
public Score add(finat int other) {
	return new Score(this.value + other);
}
public Score add(finat Score other) {
	return add(other.value);
}
```

메소드 오버로딩을 적극 사용하자
-> 다형성
( 사용자는 public api 중에서 선택해서 사용이 가능하다1 )

방어적 복사를 자주 사용하자
` List<String>temp = new ArrayList(value);`
( 비용 보다 , 다른 곳에서 접근을 막는게 더 가치가 높다! )

---

```java
finar var newHand = hand.add(card);
if(newHand.isBust()){
	return new Bust(newHand);
}
return new Hit(newHand);
```

draw 
stand
cards
calculateProfit

상태 패턴을 사용하자

```java
final var state = BlackjackGame.start(
	Card.of(Suit.CLUB,)
	Card.of()
)

public static State start(final Card first,final Card second) {
	final var hand = new Hand(first,second);
	if(hand.isBlackjack()) {
		return new Blackjack(hand);
	}
	return new Hit(hand);
}
```

상태 패턴은 어렵다,,,

패턴이 먼저가 아닌
자연스러운 흐름에서 의식 과 리팩토링을 통해 인지해나가자

if 문 로직 -> 형태 변화 규칙 -> 상태 패턴
=> 객체지향적 습관을 키워나가자
( 상태 패턴은 일반적인 백엔드가 가지기 힘듬 - 게임 도메인 )
각 도메인 마다 맞는 패턴이나 , 익숙한 패턴이 있다

자신감 있게 하나씩 키워나가자

